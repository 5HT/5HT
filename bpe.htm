<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>BPE</title>
    <link rel="stylesheet" href="deposits.css" />
</head>
<body>
<div class=menu>
<a href="index.htm">articles</a>
</div>
<hr>
<div class=app>

<h2>Business Process Engine</h2>

<div class=message>

<p>Текущий мой проект напрямую связан с моим магистерским дипломом.
Сейчас я могу смело заявлять, что работаю по специальности.
Тема моего магистрантского диплома на Факультете Прикладной
Математики была "Архитектура и программирование систем
управления бизнес-процессами". В этой работе был исследован
комплекс математических, лингвистических (как сейчас модно
говорить DSL) и других обеспечений, которые лежат в основе таких систем.</p>

<center><p>Picture 1. Business Process</p><p>
<img src="img/BPE.svg" width=600>
</center></p>

<p>В основе систем управления процессами лежат Сети Петри,
переходы между состояниями FSM тоже отмечены вершинами.
Этот математический аппарат очевидно предшествовал модели
модели акторов. В работе были рассмотрены также другие
модели организации бизнес процессов: Event-Condition-Action
модели (или как сейчас модно говорить реакционной модели),
алгоритм RETE и дедуктивные системы правил.</p>

<p>Уже тогда мной были рассмотрены все существующие на тот
момент Workflow DSL, такие как XPDL (WfMC), Skelta, OpenWFE,
Shark, J2, jBPM. Создавая тогда свою систему на .NET 1.0 я
объединил ECA и Workflow подходы. Но я тогда не знал Erlang.</p>

<p>Сейчас я реализовал аналогичную по мощности систему в 300
строк Эрланг кода. За основу я взял современный BPMN 2.0
стандарт, который объединил все существующие системы на
рынке через 8 лет после моей работы. Поскольку формат этого
блога и размер этой системы мне позволяют, я приведу
фактически весь код этого движка на Эрланге.</p>

<h3>BPMN 2.0 in Erlang</h3>

<p>Здесь конечно не все, но здесь как раз эти 20% которые покрывают 80% workflows.</p>

<div><p><center>Listing 1. BPMN 2.0 Model</center><pre>

  -record(task,         { name, roles=[], module }).
  -record(userTask,     { name, roles=[], module }).
  -record(serviceTask,  { name, roles=[], module }).
  -record(receiveTask,  { name, roles=[], module }).
  -record(messageEvent, { name, payload=[], timeout=[], module }).
  -record(beginEvent ,  { name, module }).
  -record(endEvent,     { name, module }).
  -record(sequenceFlow, { source, target }).
  -record(history,      { ?ITERATOR(feed,true), name, task }).
  -record(process,      { ?ITERATOR(feed,true), name,
                          roles=[], tasks=[], events=[],
                          history=[], flows=[],
                          rules, docs=[],
                          task,
                          beginEvent, endEvent }).
</p></pre></div>

<p>В каждом FSM есть желание триггернуть состояние напрямую.
В erlang такое тоже есть и у нас тоже есть. Я много написал
gen_server и gen_fsm. И решил не использовать gen_fsm вообще
никогда. Это broken by design elrnag otp behaviour.</p>

<div><center>Listing 2. Boundary Event</center><pre></p>  process_event(Event, Proc) ->
      Targets = bpe_task:targets(Event#messageEvent.name,Proc),
      {Status,{Reason,Target},ProcState} =
           bpe_event:handle_event(Event,
              bpe_task:find_flow(Targets),Proc),
      NewProcState = ProcState#process{task = Target},
      FlowReply = fix_reply({Status,{Reason,Target},NewProcState}),
      kvs:put(NewProcState),
      FlowReply.
</p></pre></div>

<div><center>Listing 3. Flow Processing</center><pre></p>  process_flow(Proc) ->
    Curr = Proc#process.task,
    Term = [],
    Task = bpe:task(Curr,Proc),
    Targets = bpe_task:targets(Curr,Proc),
    {Status,{Reason,Target},ProcState} 
      = case {Targets,Proc#process.task} of
         {[],Term} -> bpe_task:already_finished(Proc);
         {[],Curr} -> bpe_task:handle_task(Task,Curr,Curr,Proc);
         {[],_}    -> bpe_task:denied_flow(Curr,Proc);
         {List,_}  -> bpe_task:handle_task(Task,Curr,
                         bpe_task:find_flow(List),Proc)
    end,

    kvs:add(#history { id = kvs:next_id("history",1),
                       feed_id = {history,ProcState#process.id},
                       name = ProcState#process.name,
                       task = {task, Curr} }),

    NewProcState = ProcState#process{task = Target},

    FlowReply = fix_reply({Status,{Reason,Target},NewProcState}),
    kvs:put(NewProcState),
    FlowReply.
</p></pre></div>


<div><center>Listing 4. gen_server BPE protocol</center><pre></p>
  {get}
  {complete}
  {run}
  {until,Task}
  {complete,Stage}
  {amend,Form}
  {amend,Form,true}
  {event,Event}
</p></pre></div>

<p>In business process management the key feature of is a
compact process definitions. Here is example of Deposit Opening process
definition in simple and clean language. The web application is an
client to ACT business process server, which hosts business process context.
All the processes can be executed in attached console without web application.</p>

<p><center>Listing 5. Open Deposit BPE Process</center>
        <pre>

  deposit_app() ->

    #process { name = 'Create Deposit Account',

        flows = [
            #sequenceFlow{source='Init',      target='Payment'},
            #sequenceFlow{source='Payment',   target='Signatory'},
            #sequenceFlow{source='Payment',   target='Process'},
            #sequenceFlow{source='Process',   target='Final'},
            #sequenceFlow{source='Signatory', target='Process'},
            #sequenceFlow{source='Signatory', target='Final'}
        ],

        tasks = [
            #userTask    { name='Init',      module = deposit },
            #userTask    { name='Signatory', module = deposit},
            #serviceTask { name='Payment',   module = deposit},
            #serviceTask { name='Process',   module = deposit},
            #endEvent    { name='Final'}
        ],

        beginEvent = 'Init',
        endEvent = 'Final',
        events = [
             #messageEvent{name="PaymentReceived"}
        ]
    }.

</pre>
</p>

<p><center>Listing 5. Open Deposit BPE Actions</center>
        <pre>

  action({request,'Init'}, Proc) ->
      {reply,Proc};

  action({request,'Payment'}, Proc) ->
      Payment = bpe:doc(#payment_notification{},Proc),
      case is_tuple(Payment) of
           true  -> {reply,'Process',Proc};
           false -> {reply,'Signatory',Proc} end;

  action({request,'Signatory'}, Proc) ->
      {reply,'Process',Proc};

  action({request,'Process'}, Proc) ->
      Account = #user{id=Proc#process.id},
      kvs:add(Account),
      {reply,Proc};

  action({request,'Final'}, Proc) ->
      {reply,Proc}.

</pre>
</p>
    

<p>Thanks to compact process context the 1 million records of
process states consume only 1GB of storage.</p>

</div>
</div>
</body>
</html>
