<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>N2O Protocol</title>
    <link rel="stylesheet" href="deposits.css" />
</head>
<body>
<div class=menu>
<a href="index.html">articles</a>
</div>
<hr>
<div class=app>

<div class=message>

<h2>N2O WebSocket Protocol</h2>
<h5>Namdak Tonpa, 1 March 2015</h5>

<p>If you put regular JSON on the wire sooner or later you will discover
your own wire protocol. Here is description of our N2O open binary precise protocol.
N2O also has ASN.1 formal description, however here we will speak on it freely.</p>

<p>The only thing I want to add is that N2O protocol was created
naturally with niminal efforts, all modifications where
applied targetly and atomically. The evolution of the protocol
is open for a deeper discussion with interested party or protocol users.</p>

<p>N2O should not define any particular set of formatters.
Application developers could choose their own formatter per protocol.
E.g. N2O uses TEXT formatting for <<"PING">> and <<"N2O,">> protocol
messages, across versions N2O used to have IO message formatted with JSON and BERT both.
All other protocol messages where BERT from origin. The only thing is that protocol
formatter should be specified somehow.</p>

<blockquote><ul><li>TEXT</li>
    <li>JSON</li>
    <li>BERT</li>
    <li>MessagePack</li></ul></blockquote>

<h3>Core</h3>

<p>The core protocols shipped with N2O provide very basic but yet
powerful functionality such as reconnects, page initialization
and common client/server messaging. The core is enough for
binary upload/download, games construction and SPA applications.</p>

<h4>heart</h4>

<p>The heart protocol defined client originated messages N2O, PING and
server originated messages IO and NOP. IO message contains EVAL that
contains UTF-8 JavaScript string and DATA reply contains any binary string.
"PING" and "N2O," are defined as text 4-bytes messages and N2O could be
followed by any text string. NOP is 0-byte acknowledging packet. This is 
heart essence protocol which is enough for any rpc and code
transfering interface. Normally heart protocol is not for active
client usage but for supporting active connection with notifications
and possibly DOM updates.</p>

<div class=note><pre>1. IO tuple {io,EVAL,DATA}
2. NOP <<>>
3. N2O init marker <<"N2O,",Rest/binary>>
4. PING message <<"PING">>
</pre></div>

<br>
<p>Heartbeat protocol is essential WebSocket application
level protocol for PING and N2O initialization. It pings
every 4-5 seconds from client-side to server thus allowing
to determine client online presence. On reconnection or
initial connect client sends N2O init marker telling to
server to reinitialize the context.</p>

<h4>spa</h4>

<p>The spa protocol defined client originated messages CLIENT, SERVER and
server originated messages SERVER, IO and NOP. This protocol should be used
for normal data transfer as enveloping protocol. Client and server DATA
message should be specified for both server and client.</p>

<div class=note><pre>5. CLIENT tuple {client,DATA}
6. SERVER tuple {server,DATA}
</pre></div>

<br>
<p>Client messages usually originated at client and
represent the Client API Requests:</p>

<h4>bin</h4>

<p>The bin protocol defined client originated messages BIN and
server originated messages BINARY and NOP. This protocol part is
dedicated to huge file transfers in binary form.</p>

<div class=note><pre>7. BIN tuple {bin,DATA}
8. BINARY tuple {binary,_,_,_,_,_,_,_,_,_,_}
</pre></div>

<h3>Extensions</h3>

<p>N2O protocol is not something statically defined. It contains
unintersected protocol sections, each defines its own complete
part of functionality. You may extend the protocol sections by
implementing you own protocol with its own envelop formatter.</p>

<h4>nitrogen</h4>

<p>The nitrogen protocol defined client originated messages PICKLE/EV and
server originated messages IO and NOP. This is something taken with
historicaly reasons and roots in Rusty's Nitrogen Web Framework. This
framework is transfering RPC events to page controllers though pickle
envelop, which could also provide ciphering. N2O supports AES/CBC cypher.
EV message contains RPC specification: module, function and arguments.</p>

<div class=note><pre>9. PICKLE tuple {pickle,_,_,_}
10. EV tuple {ev,_,_,_,_}
</pre></div>

<h4>mq</h4>

<p>The mq protocol defined client originated messages SUB, UNSUB, PUB
and server originated messages MSG.</p>

<div class=note><pre>11. SUB tuple {sub,DATA}
12. UNSUB tuple {unsub,DATA}
13. PUB tuple {pub,DATA}
14. MSG tuple {msg,FROM,TO,DATA}
</pre></div>

<h4>roster</h4>

<p>The roster protocol defined client originated messages AUTH, ADD, CONFIRM,
CREATE, JOIN, MESSAGE, TYPING,  and server originated messages PERSON,
PRESENCE</p>.

<p><div class=note><pre>
15. AUTH {auth,USER,TOKEN,SERVICES}
16. PERSON {person,ID,NAMES,SURNAMES,STATUS}
17. PRESENCE {presence,SIZE,USERS}
18. ADD {add_roster,USER,STATUS}
19. CONFIRM {confirm,USER,TYPE}
20. MESSAGE {message,ID,AUTHOR,BODY,STATUS}
21. TYPING {message,AUTHOR}
</pre></div></p>

<h4>muc</h4>

<p>The multi-user chat protocol defined client originated messages JOIN
and server originated messages ROOM, ROOMEVENT, ROOMMESSAGE</p>.

<p><div class=note><pre>
22. ROOM {room,ID,NAME}
23. ROOMEVENT {room,ID,ROOM,AUTHOR,BODY}
24. ROOMMESSAGE {room,ID,AUTHOR,ROOM,BODY,STATUS}
25. JOIN {join,USER,ROOM,ANSWER}
</pre></div></p>


</div>
</div>

</body>
</html>
