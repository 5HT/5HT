% copyright (c) 2015 Synrc Research Center

\documentclass[11pt,oneside]{article}

\input{synrc.tex}
\begin{document}

\thispagestyle{empty}
\begin{center}

\begin{minipage}[t]{2cm}
    \includegraphics[scale=0.4]{img/S}
\end{minipage}
\begin{minipage}[t]{12cm}
    \begin{flushright}
        \textsc{{\Large {\bf {\color{Blue}syn}{\color{OrangeRed}rc} research center s.r.o.}}}\\
        \textsc{Roháčova 141/18, Praha 3 13000, Czech Republic}\\
    \end{flushright}
\end{minipage}

\vspace{3cm}

    \vspace{3cm}   {\Large \bf Системна інженерія та верифікація\\ \vspace{0.2cm} уніфікованого обчислювального середовища}\par
    \vspace{1cm}   {\Large \bf System Engineering and Verification\\ \vspace{0.2cm} of Unikernel Execution Environment}\par
    \vspace{3cm}   {\Large Павло Маслянко, Київський Політехнічний Інститут\par}
    \vspace{0.3cm} {\Large Максим Сохацький, Synrc Research Center\par}
    \vspace{4cm}   {\Large Листопад 2015}

\end{center}

\newpage
\vspace{2cm}
\tableofcontents
\newpage
\section{Вступ}

\vspace{1cm}

%\vspace{0.5cm}

\subsection{Системна інженерія}

   Протягом історії обчислювальної техніки було створено різні класи та способи обчислень,
   різні тоеорії та підходи до програмування таких систем, різні класи систем програмування.
   Зараз уже стало зрозумілим, що інженіринг систем які не піддаються до верифікації
   формальними методами не може бути застосований у галузях де вимоги до якості
   особливо підвищені, як то космонавтика, енергетика та телекомунікації.

\subsection{Уніфіковані обчислювальні середовища}

   Називатимемо програмні комплекси та системи, які розповсюджуються на всі прошарки моделі OSI вище фізичного,
   уніфікованими середовищами. Перелічуючи проекти, які вплинули на хід історії
   обчислювальної техніки, серед такого уніфікованих замкнених систем, можна згадати Smalltalk-80,
   створений в Xerox Parc Аланом Кеєм, якого можна назвати творцем об'єктно-орієнтованого підходу, за що він був
   удостоєний премії Тюрінга. Віртуальні машини середовища Smalltalk представляють відносно ізольовано
   по відношенню до операційної системи систему типів разом з моделью акторів, що дозволяє
   самостійно розподіляти час обчислювального середевища. Стан таких віртуальних апаратно незалежний
   та може бути перенесений на віртуальні машини які працюють на процесорах інших архітектур.
   Інший класс систем які були представлені у той час -- це Lisp машини. Вони теж були
   здатні зберігати стан своєї віртуальної машини яка,
   як і усе середовище була написана на мові Lisp. Серед експериментальних та науково-дослідних
   уніфікованих систем можна відзначити Singularity від Microsoft Research, яка давно є постачальником
   високоякісних теоретико-практичних інструментів по верифікації програмного забезпечення.
   Сучасні унфіковані системи існують на трьох мовах програмування (на OCaml це MirageOS,
   на Haskell це HaLVM, для Erlang це віртуальна машина LING, яка створена в Україні) та
   здатні виконуватися без операційної системи. В даній роботі дається обгрунтуванню вибору
   віртуальної машини Erlang та її операційної семантки у якості основи для обчислювального
   середовища та його сервісів.

   \paragraph{}
   Застосовуючи формальні методи доведення коректності велику частину має повнота за макненість системи,
   адже недоведені або неверифіковані частини можуть вплинути на детермінованість а отже якість системи.
   Тому має велике значення забезпечення виконання системи якогомога ближче до аппаратного забезпечення.
   Основні напрямки побудови замкнених середовищ на функціональних мовах програмування існують для мов Erlang, Haskell та OCaml.

\newpage
\subsection{Верифікація програмного забезпечення}

   \paragraph{}
   За багато років кількість теорій, які використовуються для побудови програмного забезпечення значно розширилися:
   починаючи з теорії компіляції сучаних функціональних мов, та систем програмування на основі теорії типів,
   включаючи сучасні моделі обчислень, які побудовані на основі лямбда числення та числення процесів, закінчуючи віртуальними
   машинами які працююсь у семантиці захищених, простих за структурою процесів, час яких розподіляється
   у прозорий та ефективний спосіб.

   \paragraph{}
   Розглядаючи системи, які піддаються формальній верифікації, кажуть про
   сертифіковане або верифіковане програмне забезпечення. Серед логічних систем, які
   застосовувалися для цього можна відзначити клас темпоральних логік для доведення
   цілісності разподілених у просторі та часі систем (приклали таких систем: NuPRL від університету Корнела в Нью-Йорку;
   TLA+ фреймворк Леслі Лампорта за який він отримав премію Тюрінга від Microsoft Research), а також системи з залежними
   типами (теорія типів Мартіна Льофа) побудовані на основі числення індуктивних конструкцій (приклади таких систем:
   Coq побудована на мові OCaml від національного науково-дослідного інституту Франції INRIA;
   Agda побудовані на мові Haskell від швецького інституту технологій Чалмерс;
   Lean побудована на мові C++ від Microsoft Research та Універсистету Каргені-Мелона;
   Idris подудована на мові Haskell Едвіна Бреді з шотландського Університету ім. св. Андрія).

\subsection{Компактні адаптивні протоколи}

   Зараз на планеті налічується близько 50 міліардів пристроїв які повинні обслуговуватися
   масштабованими ефективними серверними комплексами які гарантовано не виконують
   додаткових та непотрібних обчислень. Це потребує повного перепроектування усіх протоколів
   які виникають між компонентнами та підсистемами. Ця работа також представляє
   уніфікований та простий стек протоколів розроблюваного обчислювального середовища.

   \begin{center}
   \vspace{0.5cm}
   \includegraphics[scale=0.15]{img/protocols}
   \end{center}

\newpage

\subsection{Завдання дослідження}
\vspace{0.5cm}

   Тактична мета даної роботи -- це реалізація усіх верхніх компонентів OSI на базі
   формальної теорії та мови з залежнити типами. Побудова зручної сучасної гнучкої верифікованої теорії
   з компактною системою типів є основним завданням даної роботи. Будемо орієнтуватися
   на мінімально можливу систему типів та набір функцій які забезпечать успішне промислове
   впровадження кінцевого продукту з компактною, проте достатньо потужною системо типів.

   \paragraph{}
   В першу чергу мова йде про три найголовніші
   сервіси: збереження інформації, система управління процесами та мультиплікатор протоколів,
   який у даній системі відіграє роль сервера додатків. Успішна реалізація цих трьох систем
   дасть нам змогу будувати більш складні та масштабовані транзакційні системи та сервіси на базі
   створеної формальної теорії, а також прокладе шлях подальшому розвитку даного
   теоретико-практичного комплексу.

   \begin{center}
   \vspace{0.5cm}
   \includegraphics[scale=0.15]{img/exe-res}
   \end{center}

   \paragraph{\bf Апаратура}
   Що стосується апаратної частини моделі OSI, то тут ми будемо вважати умовно,
   що аппаратне забезпечення і так проходить усі належні види моделювань, такі як
   розрахункові імітаційні та інші. Крім того як ми знаємо верифіковані моделі уже застосовуються
   для розробки мікропроцесорів.

   \paragraph{\bf Віртуальна машина}
   Верифікована система типів середнього рівня моделі OSI --- віртуальної машини
   є предметом майбутніх досліджень. Адам Чіпала \cite{chipvm} показав як можно
   верифікувати виконання команд віртуальної машини та компіляцію цих команд в байт-код.

   \paragraph{\bf Сервіси}
   Верифікована система типів верхнього рівня моделі OSI --- це центральний фокус даногої роботи.
   Ми розглянемо декілька основних сервісів які запезпечують персистентність, виконаня процесів,
   та мультиплікацію протоколів.

   \newpage

\subsubsection{Зберігання обчислень}
   \paragraph{}
   У цій роботі ми будемо верифікувати системні бібліотеки для
   майбутньої верифікованої віртуальної машини. Зокрема значна увага буде приділятися
   послідовностям. Система персистентного зберігання послідовностей є ядром нашого
   обчислювального середовища. Властивості цієї підсистеми є основоположними
   для перевірки констистентності операційних логів розподілених базах данних.


\subsubsection{Виконання процесів}
   \paragraph{}
   Тут ми дамо формальне визначення та верифікуємо
   типи системи управління структурованими процесами або FSM автоматами.
   Бізнес-процеси це зручний та ефективний спосіб упорядкування та формалізації
   потоків даних. Ми зосередимося на найкомактніших алгебрах.

\subsubsection{Комутація протоколів}
   \paragraph{}
   Ця частина дасть відповіть на питання структурування
   протоколів та визначення універсального мультиплікатора. Буде описаний повний стек
   протоколів для IoT та WebSocket додатків.

\subsubsection{Розподілені у просторі та часі системи}

   \paragraph{}
   Сучасний розвиток техніки та теоретична межа швидкості обробки процесорів вивів на передній план алгоритми та структури
   данних які ефективно використоують розподілені у просторі та часі ресурси, як то об’єми памяті та обчислювальні потужності.
   Принципи та підходи паралельного та узгодженого програмування дають змогу масштабувати системи та обчисленя, однак
   анонсують нові теорії для забезпечення коректності в умавах підвищеної складності алгоритмів у розподілених системах,
   такі як алгоритми забезпечення консистентності та транзакційності у розподілених системах PAXOS та CR.
   Сучасні обчислювальні середовища повинні ефективно управляти великими масивами
   даних та необмежено масштабуватися. Розподілена архтітектура сервера транзакцій
   які працюють поверх формального верифікованого сховища даних буде представлена
   окремою роботою. Даний прототип існує у вигляді координатора транзакцій який працью
   за алгоритмом ланцюгової реплікації і використовує семантику сховища, яке
   у формальному вигляді представлене у цій роботі.

\subsubsection{Різні аксіоматичні рівні}

   Важливо додати, що з формальної точки зору потрібно щоби на границях
   трьох системних рівнів формальні типи дотичних логічних теорій співпадали.
   Для доведення коректності формалізовної віртуальної машини достатньо
   визначити систему типів команд мови процессор та типи їх операндів. А для
   доведення коректності верхнього рівня достатньо аксіоматизувати дотичну
   формальну теорію віртуальної машини. Тому в даній роботі буде представлена
   така публічна система типів віртуальної машини що одразу відкриє дорогу
   для деталізації і подальшої теоретичної розробки формальної теорії для віртуальної машини.

\newpage

\subsection{Структура роботи}
\vspace{0.5cm}

   \paragraph{}
   Покладаючись на аналіз рішень в області уніфікованих середовищ та
   набір математичного і лінгвістистичного забезпечення у якості формальних методів,
   ми будемо формувати формальну теорію та бібліотеку типів для формальної
   реалізації ключових підсистем.

   \paragraph{}
   Усі існуючі уніфіковоані системи, оскільки є замкеними, пропонують
   повністю свій інтерфейс взаємодії, свою операціїну семантку та свою систему типів.
   У цьому смислі наша система не є винятком і пропонує повний стек
   програмного забезпечення, ключові частини якого ми намагатимемося формально
   описати.

   \paragraph{}
   На основі створеної базової теорії та її бібліотеки типів ми створимо
   формальними методами доказову базу для кожного компонена обчислювального
   середовища, який включений в дану роботу: {\bf зберігання обчислень},
   {\bf виконання процесів}, {\bf мультиплікатор протоколів}.

   \paragraph{}
   Далі кожна така верифікована система буде транслюватися в цільову мову
   віртуальної машини обчислювального середовища, яка у загальному випадку
   може відрізнятися від вибраної нами Erlang.

   \paragraph{}
   Особливість цієї уніфікованої системи в повному та тотальному перегляді
   усіх існуючих рішень включно з базовими протоколами інтернету типу HTTP.
   Так наприклад для сервера додатків у якості транспортного протоколу
   використовується бінарний WebSocket протокол. Усі протоколи формулюються
   у вигляді алгебр над станами процесів.

\subsubsection{Уніфіковані обчислювальні середовища}

   \paragraph{}
   Об’єктом дослідження є усі можливі моделі обчислювальних середовищ в основному придатних
   до верифікованого аналізу та обробки формальними методами. Ми вибрали середовище
   основані на віртуальних машинах зі своєю системою типів та байткодом, які уже
   використовуюються у промисловій експлуатації в телекомунікайній сфері та є лідерами
   у цій області це телекомукаційна платформа Ericsson -- Erlang/OTP. Ступінь проникнення
   цієї технологій у сучасних телекомунікаціях достатньо високий, особливо завдяки
   розвиненій підтримці ASN.1, SNMP, H.262, Radius та інших промислових стандартів
   у телекомунікаційній сфері. Перші успішні масштабні проекти на Erlang були створені ще у
   1986 році, а зараз Erlang демонструє успішність завдяки таким проектам як WhatsApp, який
   обслуговує 30 міліардів повідомлень в день у порівнянні з SMS трафіком,
   який генерується щоденно у розмірі 20 міліардів повідомлень.

\newpage

\subsubsection{Формальні методи}
\vspace{0.5cm}

   \paragraph{}
   Самі формальні методи теж є частиною об’єкта дослідження. Ми досліджуємо ті структури
   та алгоритми які дадуть максимально ефективний спосіб кодування та виконнання,
   забезпечуючи при цьому семантику, яка використовуються для машинного доведення
   коректності роботи алгоритмів та узгодженості міжпроцесних протоколів.
   Ми будемо розробляти робочу формальну теорію за допомогою індуктивних типів,
   переводячи результати на мову обчислювального середовища, Erlang.

   \paragraph{}
   Побудова розподілених та паралельних, тобто здатних виконуватися на багатьох машинах одночасно, та
   узгоджених, тобто не блокуючих, а значить лінеаризованих систем управліннями процессами є побічним
   результатом який очікується від цієї роботи. Усі розподілені у просторі та часі
   протоколи ми будемо верифікувати використовуючи темпоральну логіку за допомогою системи TLA+.

\subsubsection{Робоча теорія}

   \paragraph{}
   Вибравши конкретну систему автоматичного доведення теорем на основі теорії індуктивних типів,
   ми будуємо основні типи нашої теорії і визначаємо у нашій теорії сигнатури сервісів
   нашого обчислювального середовища. Досліджуємо побудовану систему типів на предмет
   відповідності до робочого прототипу та доводимо певні базові властівості які є спільними для кожного із трьох
   сервісів включених до даної роботи. Виберемо для опрацювання робочої теорії
   систему автоматичного доведення теорем Lean від Microsoft Research в якості мови
   з залежними індуктивними типами.

\subsubsection{Формальна підсистема}

   \paragraph{}
   Кожну окрему підсистему ми будемо відокремлювати та визначати які теореми
   та які констукції використовуються для побудови підсистеми формальним способом,
   використовуючи математичні конструкції робочої теорії. У нашому випадку є три
   типи моноїдальних систем на основі яких ми можемо конструювати більш складні
   кінцеві системи-продукти для кінцевого користування та експлуатації.
   Для кожної підсистеми з цих трьох застововується подібна методологія
   доведення коректності та трансляціі математичної моделі в результуючу
   мову віртуальної машини.

\subsubsection{Результуюча мова}

   \paragraph{}
   Розроблені теореми та сигнатури
   формальної підсистеми потім компілюються або транслюються в результуючу мову віртуальної машини
   обчислювального середовища. В нашому випадку це мова Erlang та віртуальні
   машини BEAM від Ericsson, та LING від Cloudozer. Для цього нам в базовії теорії доведеться
   формально описани базові примітиви віртуальної машини Erlang та взяти їх
   у якості аксіом для нашої теорії.

\newpage
\subsection{Додаткові та дотичні теорії}
\vspace{0.5cm}
   У таксономії теоритичних сутностей умовно визначатимемо
   графічні топологічно- структурні, аналітичні, статистичні та логічні типи теорій, які
   ми використовуватимемо для опису комплесної теорії верифікованих середовищ
   послідовних обчислень розподілених узгоджених паралельних систем.\\

   \subsubsection{Теорія масового обслуговування}
   Теорія массового обслуговування застосовується для побудови
   статистичних моделей та запобігання відмов. Перші роботи у цій області
   належать шведському математику Агнеру Крурупу Ерлангу, який займався
   дослідженнями трафіка у телефонних мережах. Модель масового обслуговування достатньо
   адекватно описує роботу віртуальної машини Erlang, де клієнти -- це процеси,
   які мають черги повідомлень, та здатні відправляти заявки на обслуговування
   у такі самі черги інших процесів. Ці заявки, чи повідомлення складають певний
   протокол взаємодії у системі таких процесів. Тому тут теорія масового обслуговування
   застосовується для визначення пропускної здатності системи.

   \subsubsection{Мережі Петрі}
   Мережі Петрі в даній роботі використовуються як прототип графічного
   лінгвістичного засобу структури категорій та системи типів. Оскільки
   такі графічні засоби як UML та різноманітні окремі технологічні
   стандарти як то BPMN більше допомагають ніж мішають, була розроблена
   також і графічна мова на базі графічної мови мереж Петрі, оскільки їх
   семантика ділить один простір з тематикою даної роботи. Ми візьмемо
   лінгвістичне забезпечення Мереж Петрі як прототип для нашої власної
   мови візуалізації структур обчислень.

   \subsubsection{Теорія категорій}
   Теорія категорій як робоча структурна теорія системи типів мови Exe та
   категоріальна семантика числення процесів. Можна було би використовувати абстракну алгебру загалом,
   та теорія напівгруп, а саме напівгруп активностей, проте ми будемо використовувати
   категоріальну семантику, що стало можливо завдяки роботам Лавіра та іншим.\\

   \subsubsection{Темпоральна логіка}
   Темпоральна логіка як індуктивна теорія верифікації розподілених алгоритмів
   застосовується до доведення коррекності усіх нормалізованих підсистем. На основі
   теорії  Леслі Лампорта\cite{tla}, за яку він отримав премію Тюрінга.
   Елементи темпоральної логіки нам знадобляться для розробки теорій
   розподілених у просторі та часі алгоритмів.\\

\newpage
\subsection{Основні теорії}
\vspace{0.3cm}
   \subsubsection{$\pi$ числення}
   Теорія Пі-числення Роберта Мілнера є основним формалізмом обчислювальної
   теорії та її імплементації. З часів виникнення CSP числення розробленого Хоаром,
   Мілнеру вдалося значно розширити та адаптувати теорію до сучасних
   телекомунікаційних вимог, як наприклад хендовери в мобільних мережах.
   Основні теорми в моделі Пі-числення стосуються непротиречивості та неблокованості
   у синхронному виконанні мобільних процесів. Так як сучасний Web можно розглядати
   як телекомунікаційну систему, тому у розробці додатків можна покладатися у тому
   числі і на такі моделі як Пі-числення.

   \subsubsection{$\lambda$ числення}
   Лямбда-числення як основна абстракція обчислювальної віртуальної машини.
   Будучи внутрішньою мовою декартово-замкненої категорії лямбда числення окрім змінних
   та констант у вигляді термів пропонує операції абстракції та аплікації, що визначає
   достатньо лаконічну та потужну структуру обчислень з функціями вищих порядків,
   та метатипизаціями, такими як System F, яка була запропонована
   вперше Робіном Мілнером в мові ML, та зараз присутня в більш складних,
   таких як System F$\omega$ системах Haskell та Scala. Наша результуюча система
   типів буде тегована система типів мови Erlang.

   \subsubsection{Інтуітіоністична теорія типів Мартіна Льофа}
   Системи з залежними типами як верифікаційні математичні формальні моделі
   для доведення корректності. Система $\Sigma$ та $\Pi$ типів, як кванторів
   існування та узагальнення. Системи Mizar, Coq, Agda, Idris, F*, Lean. Ми будемо
   використовувати автоматизовану систему теорем Lean від Microsoft Research.
   \paragraph{}
   Розбудовуючи певний фреймворк чи систему конструктивними методами
   так чи інакше доведеться зробити певний вибір у мові та способі кодування.
   Так при розробці теорії абстрактної алгебри в Coq були використані
   поліморфні індуктивні структури\cite{coqalg}. Однак Agda та Idris використувують
   для побудови алгебраїчної теорії типи класів, а у Idris взагалі відсутні
   поліморфірні індуктивні структури та коіндуктивні структури. В Lean
   теж відсутні коіндуктивні структури проте повністю реалізована теорія
   HoTT на нерекурсивних поліморфних структурах що обєднує основні чотири
   класи математичних теорій: логіка, топологія, теорія множин, теорія типів.
   Як було показано Стефаном Касом\cite{kaes}, одна з
   стратегій імплементації типів класів --- це використання поліморфних структур.
   Хоча в Lean також підтримуються типи класів нами була вибрана стратегія
   імплементації нашої теорії з використаннями нерекурсивних індуктивних структур,
   що дозволить нам оперувати з персистентними структурами на низькому рівні.
   Крім того такий спосіб кодування ієрархій повністю відповідає семантиці Erlang,
   де немає типів класів, а дані передаються запаковані в кортежі-структури.


\subsection{Предмет дослідження}
\vspace{0.5cm}

   Предметом дослідження даної роботи є розробка формальних методів для побудови
   операційних середовищ та метамоделей для їх формальної специфікації. Розглянувши усі
   можливі математичні моделі опису формалізму процесів ми формуємо ряд вимог корисних
   для побудови ефективної моделі яка дозволить:

\begin{itemize}
   \item Скоротити об’єм коду на порядок
   \item Нормалізувати дані для їх статистичної обробки
   \item Легко обчислювати показники системи масового обслуговування
   \item Легко доводити коректність
   \item Мінімізувати цикл розробки програмного забезпечення
   \item Підвищити ефективність виконання
\end{itemize}

  Для забезпечення стратегії цієї роботи ми визначаємо найбільш оптимальну модель
  потоку даних та функції для їх обробки, використовуючи алгебраїчний підхід
  для опису протоколів та їх категорій. Серед основних фаз дослідження можна виділити:

\begin{itemize}
   \item Дослідження алгебраїчних структур середовища
   \item Визначення характеристик нормалізованих та оптимальних структур
   \item Побудова системи типів
   \item Визначення властивостей системи та доведення теорем
   \item Розробка системи додатків на основі метамоделі на мові Erlang
   \item Впровадження, діагностика та аналіз роботи системи
\end{itemize}

   \paragraph{}
   Іншими словами словом ми розроблюємо теорію та імплементацію мінімалістичного
   сертифікованого верифікованого операційного середовища для компонентів замнекненої системи:
   абстракції аппаратного забезпечення, мова програмування, віртуальна машина, комунікаційні
   черги, бази даних, веб сервери, сервери додатків, та усе, що піддається верифікації та по
   можливості є коректним за побудовою. Починаючи з фундаментального формалізму лямбда та пі числення,
   через абстракції віртуальної машини до віртуальної апаратури, реальні сучасні додатки та протоколи,
   закінчуючи прикладами, засобами та документацією на створене обчислювальне середовище та його модель.\\

\newpage
   \subsubsection{Алгебраїчний підхід}

   Ми будемо застосовувати алгебраїчні рекурсивні типи даних для побудови системи типів, тому
   зручно буде також застовувати алгебраїчний підхід до генералізації теорії процесів.
   З алгебраїчної точки зору процесси, або кінечні автомати, представляють собою напівгрупи дій.
   З категоріальної точки зору процесси --- це функтори які перетворюють категорії з декартовими добутками
   типів протоколу та стану процеса на категорію станів. Кожен процес визначається таким функтором, адже
   простір дій $\Sigma$ для кожного процесу є унікальний.

\begin{center}
\begin{tabular}{lcll}
$A$         &:& $\Sigma \times X \rightarrow X  $ &\\
$X$         &:& $\Sigma \times \Lambda_{X} $ &\\
            &|& $\bot                              $ &\\
$\Sigma$    &:& $ok$    & $\times\ \_$          \\
            &|& $error$ & $\times\ \_$          \\
            &|& $io$    & $\times\ \_ \times\ \_$          \\
\end{tabular}
\end{center}

   У функціональних мовах програмування така категорія будем мати вигляд програми,
   де функтор буде представлений фунцією перетворення станів процесу, а протокол
   буде типом-сумою усіх можливих запитів до процесу:

\begin{center}
\begin{lstlisting}[mathescape=true]
                  action : proto $\rightarrow$ state $\rightarrow$ state
                  state  : list proto
       definition sigma := ok + error + io

                  record proto := (data: iterator)
                  record ok    extends proto
                  record error extends proto
                  record io    extends proto := (effects: iterator)
\end{lstlisting}
\end{center}

  \subsubsection{Напівгрупа активностей}

  Дана алгебраїчна модель визначає достатньо просту та визначену структуру.
  Мета нашої структури забезпечити детермінованість послідовності,
  її початковий елемент та термінальний. 

\begin{center}
\begin{tabular}{lcl}
$spawn$       &:& $\top\ \rightarrow\ S$\\
$run$         &:& $S\ \rightarrow\ \bot$\\
$\bot$        &:& $\odot\ S\ \rightarrow\ S$\\
$complete$    &:& $\otimes\ S\ \rightarrow\ S$\\
\end{tabular}
\end{center}

  Одиниця напівгрупи
  демонструється номінально як операція запиту поточного стану процеса.
  Інша бінарна операція напівгрупи по відношеню до протокола та стану процеса $complete$
  передбачає виконання функції активності поточного кроку процесу, яка
  визначена в сигнатурі як $action: \Sigma\ \rightarrow\ P\ \rightarrow\ P$.

\begin{center}
\begin{lstlisting}[mathescape=true]

      record app (P S: Type) := (spawn  : P $\rightarrow$ S)
                                (run    : S $\rightarrow$ P)
                                (action : P $\rightarrow$ S $\rightarrow$ S)

\end{lstlisting}
\end{center}

  \subsubsection{Лінійність обчислень}
   Списки є фундаментальними структурами та найпростішим рекурсивним алгебраїчним типом.
   Природа обчислень, як результат виконання процессів теж лінійна. Можна навіть визначити
   оператор похідної, як функтор, який для алгебраїчного типу процесу буде давати список,
   а для списку буде давати скаляр. Як було показано \cite{meseguer} мережі петрі,
   а значить і процеси є моноїдами які генерують лінійну послідовність подій.

\begin{center}
\begin{tabular}{lcl}
$\Delta \ \Lambda^0$         &:& $\times^0$ \\
$\Delta \ \Lambda^{n}$       &:& $\Lambda^{n-1}$ \\
\end{tabular}
\end{center}

   \paragraph{}
   Саме лінійність кінцевого
   процессу виконання певного структурованого або циклічного алгоритму відіграє ключову
   роль у моделюванні віртуальних обчислювальних середовищ. Такі лінеаризовані системи
   уже показали свою ефективність в певному класі обчислень, таких як ланцюгова реплікація,
   реактивні системи, та інші моделі напівгруп навколо певних типів -- протоколів взаємодії між процесами.
   Крім того такі послідовності подій піддаються статистичній обробці для визначення первних кластеризацій
   та інших кореляцій у просторі та часі, тому можна говорити про певні зручні, нормалізовані системи типів для
   такого роду маніпуляцій над даними.

  \subsubsection{Управління ефектами}
   Однак що робити коли обчислення в моноїдальних категоріях проходять з помилками?
   Як обробляти ці помилки, та як ці помилки пов’язані зі слідом процесу? Таким чином кажуть
   про ефекти які можуть виникнути при роботі чистих функцій.
   Кодування ефектів за допомогою типів зараз є стандартом
   де-факто в сучасних функціональних мовах програмування. Так наприклад в мові Haskell ефекти кодуються
   за допомогою монадичних типів. Однак, насправді, достатньо було б використовувати менш загальний спосіб
   кодування єфектів у вигляді списків, з огляду на лінійність процесу обчислень. Так в мові Idris
   ефекти середовища дійсно представлені у вигляді списків. Як показано\cite{baer}, ефекти
   навіть вносяться як мовні елементи у функціональну мову, як це наприклад існує
   в імперативних мовах у вигляді типів виняткових ситуації.

   \paragraph{}
   Класично до ефектів, крім помилок та виключень, відносять також усі
   операції що взяємодіють зі змінними за межами локального контексту
   виконання функції (параметри чи локальні змінні в стеку функції).
   Також до ефектів відносят стан процессу що знаходиться контекстом
   вище ніж контекст даної функції. Однак в нашій моделі стан включений
   явно у сигнатури наших моноїдальних конструкцій.

   \paragraph{}
   Ми хочемо зробити так, аби ефекти були явними готовими до персистентності.
   Наприклад щоби можно було взяти послідовність ефектів у вигляді списку і
   передати їх по мережі чи зберегти у сховищі середовища. Таким чином ми
   пропонуємо відкриту модель кодування ефектів у вигляді дво-зв’язних
   списків (сигнатура бінарного дерева з аксесорами $next$ та $prev$).

   \paragraph{}
   Мотивація такого підходу полягає в тому, що для транзакційних систем
   в яких існує лог операцій, цей лог операції і є ефектими які виникають в процесі обчислень.
   І в розподілених системах зручно явно оперувати такими ланцюгами ефектів.
   Тому ми описуємо універсальних механізм зберігання поліморфних структур
   на базі абстрактного key-value яке нам пропонує віртуальна машина, і ефекти
   ми будемо кодувати індуктивними поліморфними структурами. Кожна послідовність ефектів та обчислень
   кодується певним типом та зберігається у сховищі під унікальним ключем. В процесі роботи
   система оепрує обчисленнями як послідовностями, і може їх склеювати, підрізати,
   пробігати та згортати.

   \paragraph{}
   Ми почнемо з двох найголовніших послідовностей $ok$ (послідовніст обчислень)
   та $error$ (послідовність помилок), а також об’єднана стурктура $io$ яка тримає
   обидва вида ефектів. Результат обчислень кожної функції ($ok$ чи $error$ в залежності від результату)
   дописуєтся у відповідний ланцюг контейнера ефектів який знаходиться близько до
   процесу який тримає стан і виконує дану функцію.

\begin{center}
\begin{tabular}{llll}
$KVS$     &:& $get$    & $\times\ \_$          \\
          &:& $put$     & $\times\ \_$          \\
          &|& $add$     & $\times\ \_$          \\
          &|& $remove$  & $\times\ \_$          \\
          &|& $cut$     & $\times\ \_$          \\
          &|& $append$  & $\times\ \_$          \\
          &|& $fold$    & $\times\ \_$         \\
\end{tabular}
\end{center}

\begin{center}
\begin{lstlisting}[mathescape=true]

  definition ids       := option $\mathbb{N}$
      record container := (top: ids) (size: $\mathbb{N}$)
      record iterator  := (id: ids) (next: ids) (prev: ids)

      record db      extends proto
      record get     extends db
      record put     extends db
      record add     extends db
      record cut     extends db
      record remove  extends db
      record append  extends db
      record fold    extends db
  definition kvs :=  get + put + add + remove +
                     append + fold + ok + error + io

      record store
     extends app kvs container :=
             (sup: list container)
             (tab: list table)
             (calculation: iterator $\rightarrow$ container $\rightarrow$ container)

\end{lstlisting}
\end{center}

\newpage
   \subsubsection{Визначення процесу}

   Щоб формально визначини процес ми спочатку визначимо домени або типи,
   які фігурують при визначенні процесу.

\begin{center}
\begin{tabular}{lcl}
                Errors &:& \#error\\
              Sucesses &:& \#ok \\
           Environment &:& \#document | \#config\\
              Taxonomy &:& \#event    | \#task   | \#flow\\
                Module &:& $\{ action : \Sigma \rightarrow P \rightarrow P \}$ \\ \hline
               Process &:& \#process\\
\end{tabular}
\end{center}

\begin{center}
\begin{lstlisting}[mathescape=true]
            record task      := (name: string)
            record event     := (name: string)
            record flow      := (source: task) (target: task)
            record process
           extends iterator :=
                   (env: list iterator)
                   (feed_id: $\mathbb{N}$)
                   (taxonomy: prod (prod (list task) (list flow)) (list event))
\end{lstlisting}
\end{center}

   \subsubsection{Управління процесами}

\begin{center}
\begin{tabular}{llll}
 $BPE$      &:& $amend$       & $\times\ \_$      \\
            &|& $complete$    & $\times\ \_$         \\
            &|& $run$         & $\times\ \_$          \\
\end{tabular}
\end{center}

\begin{center}
\begin{lstlisting}[mathescape=true]
            record p        extends proto
            record run      extends p
            record amend    extends p
            record complete extends p
        definition bpe := run + amend + complete + ok + error + io

            record proc
           extends app bpe process :=
                   (sup: list process)

\end{lstlisting}
\end{center}

  \subsubsection{Алгебра процесів}

  Алгебра процесів визначає базові операції мультиплексування двох чи декількох
  протоколів в рамках одного процесу (добуток), а також паралельного та повністю
  ізольованого запуску включно зі стеком та областю памяті (сума) на
  віртуальній машині.

\begin{center}
\begin{tabular}{lcl}
$\oplus$   &:& $P \parallel P$\\
$\otimes$  &:& $P \mid P$\\
\end{tabular}
\end{center}


\newpage
  \subsubsection{Лямбда числення}

Для розробки нашої теорії ми застосуємо інтуітіоністську теорію типів Мартіна Льофа.
Ця система типів буде застосовуватися для довення робочих теорем. База мови складає
лябмда числення як внутрішня мова декартово-замкненої категорії. Лямбда числення в своїй
основі скаладається з конструктора типу яка визначає функції та елімінатора -- аплікації
функції до аргументу.

\begingroup
\parbox[t][][l]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma\ x:A \vdash\ B$ }
\UnaryInfC{$\Gamma \vdash fun\ x : A \rightarrow B$}
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.60\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma\ f:A \rightarrow B$ }
\AxiomC{$\Gamma\ a:A$ }
\BinaryInfC{$\Gamma \vdash f \ a : B$}
\end{prooftree}

}
\endgroup

  \subsubsection{Алегбраїчні типи даних}

Далі йде внутрішня мова алгебраїчних типів даних яка складається з суми та добутку,
за допомогою яких контруюються суми-протоколи та кортежі-пакети, а також {\bf nil} типу-атому,
яким зручно термінувати рекурсивні типи даних, такі як {\bf cons}.

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash\ \bot$ }
\end{prooftree}

\begingroup
\parbox[t][][l]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma \vdash\  a:A$ }
\AxiomC{$\Gamma \vdash\  b:B$ }
\BinaryInfC{$\Gamma \vdash\  (a,b) : A \times B$ }
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash\  a:A$ }
\AxiomC{$\Gamma \vdash\  b:B$ }
\BinaryInfC{$\Gamma\vdash a\ |\ b : A \otimes B$}
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.60\textwidth}{


\begin{prooftree}
\AxiomC{$\Gamma\ x: A \times B$ }
\UnaryInfC{$\Gamma \vdash fst\ x : A$;
           $\Gamma \vdash snd\ x : B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ x: A \otimes B$ }
\UnaryInfC{$\Gamma \vdash inl\ x : A$;
           $\Gamma \vdash inr\ x : B$}
\end{prooftree}


}
\endgroup


  \subsubsection{Процеси і протоколи}

Також ми анонсуємо процес як фундаменльний тип даних, подібний до функції але який здатний
тритати певний стан у вигляді типа коротежа та бути здатним реагувати на повідомлення суми.

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash e : Error$ }
\AxiomC{$\Gamma\ \vdash h : History$ }
\BinaryInfC{$\Gamma \vdash module : a : \Sigma \times P \rightarrow P $}
\AxiomC{$\Gamma\ \vdash env : Document$ }
\AxiomC{ $\Gamma\ \vdash s : Event | Task | Flow$ }
\TrinaryInfC{$\Gamma \vdash p : Process$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash \Sigma, X$ }
\AxiomC{$\Gamma\ \vdash p : Process$ }
\BinaryInfC{$\Gamma \vdash {spawn}_{\Sigma}\ p : \pi $}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash spawn : \pi$ }
\AxiomC{$\Gamma\ \vdash m : \Sigma$ }
\BinaryInfC{$\Gamma \vdash {join}_{\Sigma}\ (m, spawn) \rightarrow \Sigma$;
            $\Gamma \vdash {async}_{\Sigma}\ (m, spawn) \rightarrow \Sigma$}
\end{prooftree}


\newpage

  \subsubsection{Логіка та квантори}

Далі йдуть квантори $\forall$ та $\exists$ які теж виражаються як конструкції типів:

\begingroup
\parbox[t][][l]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma\ x: A \vdash B$ }
\AxiomC{$\Gamma\ \vdash A$ }
\BinaryInfC{$\Gamma\ \vdash \Pi (x : A) B $}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ x: A \vdash B$ }
\AxiomC{$\Gamma\ \vdash A$ }
\BinaryInfC{$\Gamma\ \vdash \Sigma (x : A) B $}
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.60\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash a : A$ }
\AxiomC{$\Gamma\ x : A \vdash B$ }
\AxiomC{$\Gamma\ b : B (x=a)$ }
\TrinaryInfC{$\Gamma\ \vdash (a,b) : \Pi (x : A) B $}
\end{prooftree}


\begin{prooftree}
\AxiomC{$\Gamma\ \vdash a : A$ }
\AxiomC{$\Gamma\ x : A \vdash B$ }
\AxiomC{$\Gamma\ b : B (x=a)$ }
\TrinaryInfC{$\Gamma\ \vdash (a,b) : \Sigma (x : A) B $}
\end{prooftree}

}
\endgroup

\begingroup
\parbox[t][][l]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash x: A$ }
\AxiomC{$\Gamma\ \vdash x': A$ }
\BinaryInfC{$\Gamma\ \vdash Id_A (x,x')$}
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.60\textwidth}{

}\endgroup


\begin{center}
\begin{tabular}{lll}
  рефлексивність &:& $Id_A(a,a)$ \\
  підстановка     &:& $Id_A(a,a') \rightarrow B(x=a) \rightarrow B(x=a')$ \\
  симетричність  &:& $Id_A(a,b) \rightarrow Id_A(b,a)$  \\
  транзитивність &:& $Id_A(a,b) \rightarrow Id_A(b,c) \rightarrow Id_A(a,c)$ \\
  конгруентність &:& $(f: A \rightarrow B) \rightarrow Id_A(x,x') \rightarrow Id_B(f(x),f(x'))$ \\
\end{tabular}
\end{center}



  \subsubsection{Контраваріантні процеси}

  Ко-процеси це моноїди з перевернутою стрілкою, які визначають зворотній шлях виконання
  події та обернену зміни стану в зворотньому порядку. З точки зоро типів нічого не змінюється,
  однак оберненої функції-фунтора процесу-моноїда може і не існувати. Процеси які є
  одночасно коваріантними та контраваріантними називаються інваріантними процесами, сигнатура яких
  алгебраїчно збігається з сигнатурою бінарного дерева.

\begin{center}
\begin{tabular}{lcl}
$X$         &:& $\times^{i}$ \\
$\Lambda$   &:& $\times^{4} \ I \ X \ \Lambda_{next} \ \Lambda_{prev}$ \\
            &|& $\bot$ \\
\end{tabular}
\end{center}

\begin{center}
$st(p) = p(st-1)$ — застосування функції до протокольної заявки та стану процесу
$p-1(st) = st-1$ — обернена функція
\end{center}

  \subsubsection{Типи процесів}

\begin{center}
\begin{tabular}{lll}
         $action$ &:& ${proc}_{Proc}\ (Proc\ |\ \Sigma) \times process \rightarrow process$ \\
         $event$  &:& ${proc}_{App}\ (App\ |\ \Sigma) \times cx \rightarrow cx$ \\
         $operation$    &:& ${proc}_{Store}\ (Store\ |\ \Sigma) \times container \rightarrow container$ \\
\end{tabular}
\end{center}

\newpage

\subsection{Віртуальна машина}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.3]{img/exe-legend}
\caption{Базові елементи віртуального середовища}
\end{figure}

{\bf action} is the piece of code applied to message using pattern matching.\\
{\bf record} is the tuple that defines a protocol.\\
{\bf client} is the true customer of the system who is using service on daily basis.\\
{\bf server} is the process nicely scheduled by the system.\\
{\bf feed} is the server managed list of records.\\
{\bf table} is the ixset or ets based queryable tables.\\

\subsection{Сигнатури сервісів}

{\bf app} is the web clients monoidal state machine.\\
{\bf proc} is the oriented graph monoidal executional engine.\\
{\bf store} is the 2-category key-value database.\\

\begin{center}
\begin{tabular}{lll}
           $store^3$ &:& $\times^3 \Lambda_{id_seq}\ \Lambda_{table}\ \Lambda_{feed}$ \\
          $roster^2$ &:& $\times^2 \Lambda_{feed}\ \Lambda^2_{feed}$ \\
             $app^2$ &:& $\times^2 \Lambda_{session}\ \Lambda_{proc}$ \\
           $depot^1$ &:& $\times^1 \Lambda_{account}$ \\
             $act^1$ &:& $\times^1 \Lambda_{proc}$ \\
\end{tabular}
\end{center}

\newpage

\subsection{Мета дослідження}
\vspace{0.5cm}
   Основною метою дослідження є збезпечення виконання критеріїв відповідності
   показників ефективності, детермінованості та якості шляхом впровадження
   результату даної теорії, комплексу програмного забезпечення у виробничий процес.

   За рахунок компактності передбачається значна економія складності та простота у експлуатації,
   що веде до сниження собівартості впровадження. Коректність передбачає заміну
   автоматозаваному тестуванню, а закритість середовища дозволяє гнучко використовувати
   середовище на різних виробничих платформах.
   \\

\subsection{Результати}
\vspace{0.5cm}
   Одна з останніх систем, яка була впроваджена для заміни існуючої системи, мала
   показники у співвідношенні розміру 10, швидкості 20 та виконання 3. Інші системи
   у історичній послідовності мали ці показники такими 10, 2, 8, та 19, 5, 5.
   В середньому показники ефективності відрізняються більше ніж на пів порядка
   в кращу сторону після впровадження продуктів на базі розробленої моделі.
   Існують продукти також і на інших мовах програмування.

\newpage
\subsection*{Додаток А. Персистентність послідовностей}

Для забезпечення персистентного зберігання послідовностей використовується
очевидний спосіб зберігання елементів послідовності у key-value сховищі разом
з референсами на наступні, та у випадку контраварінтних процесів, також і на
попередні елементи у послідовності. Таким чином ми можемо перелічити усі
елементи послідовності. Акумулятор розділеної у просторі та часі операції
накопичує усі необхідні агрегації після кожної операції з послідовністю. Таким
чином похідна від алгебраїчної структури списку буде скаляр-акумулятор після
завершення перелічення.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{img/exe-kvs-api}
\caption{Типи, функції та модулі}
\end{figure}

В даній роботі ми розглянемо формальні визначення сховища, його референсів, послідовностей через рекурсивні
алгебраїчні типи даних та процеси, черги яких забезпечують впорядкованість послідовності
запитів до послідовностей, що веде до лінійності операції у часі.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{img/exe-kvs}
\caption{Послідовності ключів, таблиць, індексів та інтерфейс}
\end{figure}

\newpage
\subsection*{Додаток Б. Мультипротокольный чат}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.1]{img/exe-roster-api}
\caption{Типи, функції та протокол}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.3]{img/exe-roster}
\caption{Cписки кімнат та користувачів і їхні чати, дві таблиці та протокол}
\end{figure}



\newpage
\begin{thebibliography}{9}

\bibitem{lof}      Per Martin-Löf \textit{Intuitionistic Type Theory.} 1984
\bibitem{erl}      J.Armstrong. \textit{Making reliable distributed systems in the presence of sodware errors.} 2003.
\bibitem{comm}     Robin Milner. \textit{ A Calculus of Communicating Systems.} 1986.
\bibitem{lawvere}  William Lawvere. \textit{Conceptual Mathematics.} 1997.
\bibitem{pierce}   Benjamin Pierce. \textit{Basic category theory for computer scientist.} 2004.
\bibitem{mclane}   Сандерс Мак Лейн. \textit{Категории для работающего математика.} 2004.
\bibitem{tla}      Leslie Lamport. \textit{Specifying Systems.} 2004.
\bibitem{barrtri}  Michael Barr and Charles Wells. \textit{Toposes, Triples and Theories.} 2000.
\bibitem{barrcat}  Michael Barr and Charles Wells. \textit{Category Theory for Computing Science.} 1995.
\bibitem{bakur}    И.Бакур, А.Деляну. \textit{Введение в теорию категори и функторов.} 1972.
\bibitem{commpi}   Robin Milner. \textit{Communicating and Mobile Systems: The $\pi$-calculus.} 1999.
\bibitem{polypi}   Robin Milner. \textit{The Polyadic $\pi$-Calculus: A Tutorial.} 1993.
\bibitem{mass}     Коваленко. \textit{Теория Массового Обслуживания.} 1965.
\bibitem{meseguer} Meseguer, Montanari.  \textit{Petri Nets Are Monoids.} 1990.
\bibitem{waddual}  Philip Wadler \textit{Call-by-Value is Dual to Call-by-Name.} 1000
\bibitem{seserl}   D.Mostrous, V.Vasconcelos \textit{Session Typing for a Featherweight Erlang.} 1990.
\bibitem{suberl}   S.Marlow, P.Wadler \textit{A practical subtyping system for Erlang.} 1997
\bibitem{upserl}   A.Lindgren \textit{A Prototype of a Soft Type System for Erlang.} 1996
\bibitem{mcbride}  C. McBride. \textit{Dependently Typed Func- tional Programs and their Proofs.} 1999
\bibitem{mcbrider} C. McBride. \textit{The Derivative of a Regular Type is its Type of One-Hole Contexts.}
\bibitem{schwarz}  C. Schwarzweller. \textit{Mizar Veri cation of Generic Algebraic Algorithms.} 1997
\bibitem{mourael}  L.Moura., S.Kong \textit{Elaboration in Dependent Type Theory.} 1997
\bibitem{coqhuet}  T.Coquand, G.Huet \textit{The Calculus of Constructions.} 1988
\bibitem{lampax}   L.Lamport \textit{Paxos Made Simple.} 2001
\bibitem{chipvm}   A.Chlipala \textit{Certified Programming with Dependent Types} 2015
\bibitem{chipintro} A.Chlipala \textit{An Introduction to Programming and Proving with Dependent Types in Coq} 2010
\bibitem{coqalg}   H.Gueves, R.Pollak, F.Wiedijk, J.Zwanenburg \textit{A Constructive Algebraic Hierarchy in Coq} 2002
\bibitem{idris}    E.Brady \textit{Programming in IDRIS: A Tutorial} 2015
\bibitem{kaes}     S.Kaes \textit{http://tuprints.ulb.tu-darmstadt.de/epda/000544/diss.pdf} 2005
\bibitem{baer}     A.Baer \textit{Programming with Algebraic Effects and Handlers} 2012
\bibitem{harpl}    R.Harper \textit{Practical Foundations for Programming Languages} 2015
\bibitem{agdaio}   A.Jeffrey, J.Rathke \textit{The Lax Braided Structure of Streaming I/O} 1998
\bibitem{bell}     A.Jeffrey \textit{Linear-time Temporal Logic Propositions as Types Proofs as Functional Reactive Programs} 2012
\bibitem{wadler}   P.Wadler \textit{Propositions as Types} 2014
\bibitem{moneff}       N.Benton, J.Hughes,E.Moggi \textit{Monads and Effects} 2002
\bibitem{mcbrideapp}   C.McBride, R.Patterson. \textit{Applicative programming with effects} 2002

\end{thebibliography}

\end{document}
