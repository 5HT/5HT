<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
  </head>
    <title>Exe Language</title>
    <link rel="stylesheet" href="5HT.css" />
</head>
<body>
<div class=menu>
<a href="index.html">articles</a>
</div>
<hr>
<div class=app>

<div align=right>FROM: 5HT<br>
                   TO: PUBLIC<br>
                 DATE: 1 OCT 2015</div>

<h2>Exe Language</h2>
<h4>TL;DR — certified executional environment of sequentional evaluations
            in process calculus on real hardware.</h4>

<h3>Abstract</h3>

<p>Developing theory, model and implementation of minimalistic executive environment
   for a full application stack of components:
   hardware abstraction, language virtual machine, message queue,
   database, HTTP and websocket servers, web application framework etc that is normalized
   for mass data usage, correct by construction and is usable today.</p>

<p><b>Keywords</b>:

    Unikernel, Full-stack, Specification, Formal Methods,
    Certification, Event Streaming, Time Series,
    Protocol Analysis, Statistics.</p>

<h2>The Idea and its space</h2>

<p>Exe Language is an attempt to formally specify and validate the inter-component
   communications using such tools TLA+ — a model checker for distributed systems.
   But Exe is not limited to temporal logic, it also provides type theoretical
   notation, graphical language based on Petri Nets, inner semantics of pi-calculus.
   Here is the list of theories Exe Language can be expressed in:</p>

   <ul><li>type theory</li>
       <li>temporal logic</li>
       <li>linear algebra</li>
       <li>mass service</li>
       <li>process calculus</li>
       <li>messaging language</li></ul>

<p>and other types of foundations for easier and more effective</p>

   <ul><li>statistical analisys of event streams</li>
       <li>performance measurement of mass service</li>
       <li>correctness and soundness of execution system</li>
       <li>application lifecycle of packages</li> </ul>

<p>targeting</p>

   <ul><li>all OSI levels</li></ul>


<h2>Behavior of Time Series</h2>

<p>According to TLA+ behaviors is the chronological sequence of states.
   This is the basic representation of process protocols, iterators and
   other chain based data. For statistical software like R or Julia you
   also need to provide your data as a time series of some state. Seems like
   treating any data as arrays of records is the best way to handle it.
   The fact that the event stream has a constant record in its base
   us to the domain of monoidal actions.</p>

   <p>The other goodie about recorded event stream is that system
      can be replayed starting from initial system state similar to how it's happens
      in log-based replicated databases.
      This opening the space to distributed consistent transactions streams
      such as CR&nbsp;and&nbsp;TPS.</p>

<center><p>Recorded Event Stream</p><p>
<img src="img/exe-ev.svg" width=400>
</center></p>


<p><center>
states per feed per day<br>
states monthly<br>
states per seconds<br>
latency<br>
capacity<br>
</center></p>

<p>The iteration of system or protocol messages is taken as recorded
   behavior of the system. The iteration of data messages is taken as
   persistent feeds. The system itself consist of different protocol
   bands which are tuples definitions. These protocol bands called
   applications and the overall system state is just zip of protocol
   bands which are given in application band signature list.</p>

<h2>Linearizability</h2>

<p>Linearizability is a key feature in one to many relation, storing the sequences,
   iterators and execution logs. Vector of two elements can encode binary trees
   and confluent case — lists.
   The main trick is the lists is best to encode the sequence of execution,
   data parameters, code itself, and are easy to store in KV stores.
   The linear nature of executions helps in such protocols as XA, Chain
   Replication and RETE matching.
   The lists are also a foundation to virtual machine's messaging queues
   and other core data structures.</p>

<center><p>Iterator over Chain</p><p>
<img src="img/exe-feed.svg" width=400>
</center></p>

<h2>Lightweight Unikernel Environments</h2>

<p>During the years various computer systems designs were changed and not
   all good theories were met with good implementations. From the ancient
   full-stack Lisp&nbsp;Machines, Smalltalk virtual machine which was able
   to transfer their state on different platform, and modern executional
   platforms like managed object-oriented CLR, functional
   Haskell and Erlang. At the base however you still observe UNIX or Windows&nbsp;NT
   based executional environments which is far from being verifiable and correct
   moreover they consume more power because of layering the abstractions.
   Languages like Erlang, Haskell and OCaml are most
   suited for the further eveloving of correctness and provability. They provide
   LING, HaLVM and Mirage lightweight unikernels respectively.</p>

<p>If you ask me to find other words to describe this work I would say
   that this work is an attempt to build close to theoretical adequate and precise
   executional environment that is easy to be verified and managed,
   encoded in most effective way, optimized by defition and construction,
   that relies close to hardware and provides top level modern
   software language access in Erlang.</p>

<h2>Satisfaction Landscape</h2>

<p>Whenever customer is being satisfied this joy is always fall into the following categories:</p>

<ul><li>time: duration, development, latency, run, life</li>
    <li>quality: complexiti, price, simplicity, reliability</li>
    <li>people: deterministic, usability</li>
    <li>resources: money, aux, maintanance, data, cpu</li>
    </ul>
<p></p>

<p>Technical Landscape:</p>

<ul><li>Band <font color=silver>22MB/s</font></li>
    <li>Capacity <font color=silver>30K or 100K of bands</font></li>
    <li>Rates <font color=silver>100M/d — TPS<br>
                                <div style="margin-left:65px;">30K/s — N2O<br>
                                 1K/s — XA </font></div></li>
    <li>Latency <font color=silver>30ms 300ms</font></li>
    </ul>

<p>Target areas:</p>

<ul><li>Telecom and Internet</li>
    <li>Business and Banking industry</li>
    <li>WebSocket and IoT</li></ul>

<h2>Constructing the Specfication Language</h2>

<h3>Characteristics</h3>

<p>
• Ease of expressing constructs arising in problems.<br>
• Suggestivity.<br>
• Ability to subordinate detail.<br>
• Economy.<br>
• Amenability to formal proofs.<br>
</p>

<h3>Exe Legend and Petri Process sample</h3>

<p>We will extent Petri nets graphical language alphabet with several letters up to seven.
   This language preserve message-passing semanthics along with core primitives
   such as <b>client</b> or <b>server</b> process, <b>feed</b> chains or indexed <b>tables</b> (B+,B*).
   We will use this language also to define the signatures of top-level applications.
   </p>

<center>
<img style="align:float;" src="img/exe-legend.svg" height=300><img style="margin-left:200px;align:float;"src="img/exe-proc.svg" height=300>
</center>

<h3>Exe Virtual Machine</h3>

<p>
<b>action</b> is the piece of code applied to message using pattern matching.<br>
<b>message</b> is the tuple or record that defines a protocol.<br>
<b>client</b> is the true customer of the system who is using service on daily basis.<br>
<b>server</b> is the process nicely scheduled by the system.<br>
<b>feed</b> is the <b>server</b> managed chain of <b>messages</b>.<br>
<b>table</b> is the <b>ixset</b> or <b>ets</b> based queriable tables.
</p>

<h3>Core</h3>

<code>

         I = init/1
         T = term/1
   Element = html | body | h1 | div | br | table | head ...
     Field = binary | integer | list | tuple | atom | input | option.
     Event = 3 info
           | 1 proc
           | 1 event
           | 2 action
           | 7 tx.
</code>

<h3>Types</h3>

<code>
        IO = { io, Eval, Data }.
     Error = { error, _ }.
        OK = { ok, _ }.
      Flow = { Task, Task }.
       App = { Proc,             State     I, T, Events,  spawn, push, pull }.
      Proc = { { Tasks, Flows }, State,    I, T, Events,  spawn, push, pull }.
      Feed = { summary,          Iterator, I, T, Events,  spawn, push, pull }.
  Iterator = { Record,   next,   prev }.
  Customer = { User,             Accounts, I, T, Events,  spawn, push, pull }.
   Account = { Txs  }  | Customer.
    Record = { Fields  }.
     Table = { Fields  }.
  Database = { Tables, Feeds, Generators }.
     Chats = { Public, Privates }.
  Document = { Fields, Sections, Buttons, Task }.
     Event = { Message, { Source, Target },     Time, Topic }.
   Message = { Payload, { User, User },         Time, Topic }.
     Entry = { Payload, { User, User },         Time, Topic }.
        Tx = { Record,  { Account, Account },   Time, Money }.
</code>

<h3>Categories</h3>

<code>

       App = { M, S, I, T, E, spawn, push, pull }
           : Customer
           | Proc
           | Feed.
</code>

<code>
        Еv = { M, P, T, C  }
           : Event
           | Message
           | Entry
           | Tx.

</code>



<h3>Protocol Bands</h3>

<table cellspacing=10>
<tr><td>2005</td>
    <td>2013</td>
    <td>2013</td>
    <td>2015</td></tr>
<tr valign=top>
<td bgcolor="#f5f5f5">
<code>
 BPE = 15 process
     |  1 event
     |  1 amend
     | 11 complete 

</code>
</td>
<td>
<code>
 N2O = 2 io
     | 1 client
     | 1 server
     | 8 ftp
</code>
</td>
<td>
<code>
 KVS = 2 get
     | 2 put 
     | 1 add
     | 1 remove
</code>
</td>
<td>
<code>
 MQS = 2 sub
     | 1 unsub
     | 2 pub
     | 3 msg
</code>
</td>
</tr></table>



<!--h3>Operational Semantic</h3>

<code>
    | #state { id = 1 }
    | #state { id = 2 }
    | #state { id = 3 }
</code>

<h3>Folds</h3>

<code>
    [String|List] = Params

    par X {C,R} atom X -> {[],    [{X,C}|R]};
    par X {C,R} false  -> {[X|C], R}.

    run {Fun,Arg} []  -> errors Profile:Fun Arg;
    run {Fun,Arg} Err -> {error,Err}.

    any {error,_} flatten fold $ run [] fold par {[],[]} map atomize Params.
</code-->




<h2>Application Band Signatures</h2>


<h3>Business Process</h3>

<center><p>Picture 1. BPE Application</p><p>
<img src="img/exe-bpe.svg" width=320>
</center></p>


<h3>Application Server</h3>

<center><p>Picture 1. N2O Application</p><p>
<img src="img/exe-n2o.svg" width=500>
</center></p>

<h3>Database</h3>

<center><p>Picture 1. KV Application</p><p>
<img src="img/exe-store.svg" width=400>
</center></p>

<h3>Message Queue</h3>

<center><p>Picture 1. One-to-one and one-to-many channels with coordination tables</p><p>
<img src="img/exe-mq.svg" width=420>
</center></p>

<h3>Roster</h3>

<center><p>Picture 1. Chat Application</p><p>
<img src="img/exe-chat.svg" width=600>
</center></p>

<h3>Distributed Transactions</h3>

<center><p>Picture 1. The example with VNode hashring of 64 on a cluster with 3 nodes</p><p>
<img src="img/exe-xa.svg" width=520>
</center></p>

<h2>Research</h2>

<h3>Object</h3>

<ul><li>Software at all OSI levels.</li>
    </ul>

<h3>Purpose</h3>

<p>Compact, adequate and precise typed executional environment for the OSI stack.
   Compact enought for quick check. Adequate enough to theorethical models.</p>

<h3>Result</h3>

<p>The end result of the project is a complex thing that should in its fullness consist of:</p>

<ul><li>Virtual Machine BEAM or LING</li>
    <li>Exe Language</li>
    <li>Application Domain Languages</li>
    <li>Protocols</li>
    <li>Tools</li>
    <li>Types and Frameworks</li>
    <li>Synrc Sources</li>
    <li>Sample Applications</li>
    <li>Documentation with Full-text Search</li>
    <li>Success Stories</li>
    </ul>
